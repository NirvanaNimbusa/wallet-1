// Generated by LiveScript 1.6.0
(function(){
  var getCoins, ref$, objToPairs, map, pairsToObj, each, find, guid, waitFormResult, changeAmount, div, plus, protect, navigate, useNetwork, getBalance, buildInstall, buildInstallByName, backgroundRefreshAccount, Web3, state, titles, showCases, buildGetBalance, buildSendTransaction, buildContract, buildNetworkEthereum, buildOtherNetworks, buildNetworkSpecific, buildApi, buildUse, getApis, clearApi, refreshApis, setupRefreshTimer, slice$ = [].slice, toString$ = {}.toString;
  getCoins = require('./plugin-loader.ls').getCoins;
  ref$ = require('prelude-ls'), objToPairs = ref$.objToPairs, map = ref$.map, pairsToObj = ref$.pairsToObj, each = ref$.each, find = ref$.find;
  guid = require('./guid.ls');
  waitFormResult = require('./send-form.ls').waitFormResult;
  changeAmount = require('./calc-amount.ls').changeAmount;
  ref$ = require('./math.ls'), div = ref$.div, plus = ref$.plus;
  protect = require('protect');
  navigate = require('./navigate.ls');
  useNetwork = require('./use-network.ls');
  getBalance = require('./api.ls').getBalance;
  ref$ = require('./install-plugin.ls'), buildInstall = ref$.buildInstall, buildInstallByName = ref$.buildInstallByName;
  backgroundRefreshAccount = require('./refresh-account.ls').backgroundRefreshAccount;
  Web3 = require('web3');
  state = {
    time: null
  };
  titles = ['name@email.com', 'name.ethnamed.io', 'domain.com'];
  showCases = function(store, arg$, cb){
    var title, titles;
    title = arg$[0], titles = slice$.call(arg$, 1);
    if (title == null) {
      return cb(null);
    }
    store.current.sendToMask = title;
    return setTimeout(function(){
      return showCases(store, titles, function(){
        return cb(null);
      });
    }, 1000);
  };
  buildGetBalance = function(store, coin){
    return function(cb){
      var network, wallet;
      network = coin[store.current.network];
      wallet = coin.wallet;
      return getBalance({
        token: coin.token,
        network: network,
        address: wallet.address
      }, cb);
    };
  };
  buildSendTransaction = function(store, coin){
    return function(tx, cb){
      var network, to, data, decodedData, value, gas, ref$, id, current, send, amountObtain, amountObtainUsd, amountSendUsd, amountSendFee, amountSendFeeUsd, proposeEscrow, amountSend, wallet, helps;
      network = coin[store.current.network];
      if (toString$.call(tx).slice(8, -1) !== 'Object') {
        return cb("Transaction is required");
      }
      to = tx.to, data = tx.data, decodedData = tx.decodedData, value = tx.value, gas = tx.gas;
      if (toString$.call(tx.to).slice(8, -1) !== 'String') {
        return cb("Recipient (to) is required");
      }
      if ((ref$ = toString$.call(value).slice(8, -1)) !== 'String' && ref$ !== 'Number') {
        return cb("Value is required");
      }
      id = guid();
      current = store.current;
      send = current.send;
      amountObtain = '0';
      amountObtainUsd = '0';
      amountSendUsd = '0';
      amountSendFee = '0';
      amountSendFeeUsd = '0';
      proposeEscrow = false;
      amountSend = div(value, Math.pow(10, network.decimals));
      wallet = find(function(it){
        return it.coin.token === coin.token;
      })(
      store.current.account.wallets);
      importAll$(send, {
        to: to,
        data: data,
        decodedData: decodedData,
        network: network,
        coin: coin,
        wallet: wallet,
        value: value,
        gas: gas,
        id: id,
        amountSend: amountSend,
        amountObtain: amountObtain,
        amountObtainUsd: amountObtainUsd,
        amountSendUsd: amountSendUsd,
        amountSendFee: amountSendFee,
        amountSendFeeUsd: amountSendFeeUsd,
        proposeEscrow: proposeEscrow
      });
      changeAmount(store, amountSend);
      navigate(store, 'send');
      helps = titles.concat([network.mask]);
      showCases(store, helps, function(){});
      return waitFormResult(id, function(err, data){
        if (err != null) {
          return cb(err);
        }
        return cb(null, data);
      });
    };
  };
  buildContract = function(store, methods, coin){
    return function(abi){
      return {
        at: function(address){
          var sendTransaction, network, web3;
          sendTransaction = methods.sendTransaction;
          network = coin[store.current.network];
          web3 = new Web3();
          web3.setProvider(new web3.providers.HttpProvider(network.api.web3Provider));
          web3.eth.sendTransaction = function(arg$, cb){
            var value, data, to;
            value = arg$.value, data = arg$.data, to = arg$.to;
            return sendTransaction({
              to: to,
              data: data,
              value: value
            }, cb);
          };
          return new web3.eth.Contract(abi, address);
        }
      };
    };
  };
  buildNetworkEthereum = function(store, methods, coin){
    var sendTransaction, getBalance, contract;
    sendTransaction = methods.sendTransaction, getBalance = methods.getBalance;
    contract = buildContract(store, methods, coin);
    return {
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      contract: contract
    };
  };
  buildOtherNetworks = function(store, methods, coin){
    var sendTransaction, getBalance, contract;
    sendTransaction = methods.sendTransaction, getBalance = methods.getBalance;
    contract = function(){
      throw "Not Implemented For this network";
    };
    return {
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      contract: contract
    };
  };
  buildNetworkSpecific = function(store, methods, coin){
    var builder;
    builder = (function(){
      switch (false) {
      case coin.token !== 'eth':
        return buildNetworkEthereum;
      default:
        return buildOtherNetworks;
      }
    }());
    return builder(store, methods, coin);
  };
  buildApi = function(store, coin){
    var sendTransaction, getBalance, methods;
    sendTransaction = buildSendTransaction(store, coin);
    getBalance = buildGetBalance(store, coin);
    methods = {
      sendTransaction: sendTransaction,
      getBalance: getBalance
    };
    return buildNetworkSpecific(store, methods, coin);
  };
  buildUse = function(web3, store){
    return function(network){
      return useNetwork(web3, store, network, function(){});
    };
  };
  getApis = function(cweb3, store){
    return pairsToObj(
    map(function(it){
      return [it.token, buildApi(store, it)];
    })(
    getCoins()));
  };
  clearApi = curry$(function(cweb3, name){
    var ref$;
    return ref$ = cweb3[name], delete cweb3[name], ref$;
  });
  refreshApis = function(cweb3, store){
    var ref$, apis;
    each(clearApi(cweb3))(
    (ref$ = refreshApis.prev) != null
      ? ref$
      : []);
    apis = getApis(cweb3, store);
    importAll$(cweb3, apis);
    return refreshApis.prev = Object.keys(apis);
  };
  setupRefreshTimer = function(arg$){
    var refreshTimer, refreshBalances;
    refreshTimer = arg$.refreshTimer, refreshBalances = arg$.refreshBalances;
    if (toString$.call(refreshTimer).slice(8, -1) !== 'Number') {
      return;
    }
    clearTimeout(setupRefreshTimer.timer);
    return setupRefreshTimer.timer = setTimeout(refreshBalances, refreshTimer);
  };
  module.exports = function(store, config){
    var refreshTimer, cweb3, use, install, installByName, refreshBalances, refresh, web3;
    refreshTimer = config != null ? config.refreshTimer : void 8;
    cweb3 = {};
    use = buildUse(cweb3, store);
    install = buildInstall(cweb3, store);
    installByName = buildInstallByName(cweb3, store);
    refreshBalances = function(cb){
      setupRefreshTimer({
        refreshTimer: refreshTimer,
        refreshBalances: refreshBalances
      });
      return backgroundRefreshAccount(cweb3, store, function(err){
        return typeof cb == 'function' ? cb(null) : void 8;
      });
    };
    setupRefreshTimer({
      refreshTimer: refreshTimer,
      refreshBalances: refreshBalances
    });
    refresh = function(cb){
      refreshApis(cweb3, store);
      return refreshBalances(cb);
    };
    refreshApis(cweb3, store);
    web3 = new Web3();
    importAll$(cweb3, {
      utils: web3.utils,
      use: use,
      refresh: refresh,
      install: install,
      installByName: installByName
    });
    return cweb3;
  };
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
